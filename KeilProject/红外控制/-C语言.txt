红外线遥控解码接收程序-C语言
#include <regx51.h>

#define uchar unsigned char
#define uint          unsigned int

#define           IR_RE P3_2

bit           k=0;                                              //红外解码判断标志位，为0则为有效信号，为1则为无效

uchar          date[4]={0,0,0,0};                                //date数组为存放地址原码，反码，数据原码，反码


/*--------------------------延时1ms程子程序-----------------------*/
delay1000()             
{
uchar i,j;
i=5;
do{j=95;
          do{j--;}
          while(j);
          i--;
          }while(i);
}

/*---------------------------延时882us子程序-----------------------*/

delay882()
{
uchar i,j;
i=6;
do{j=71;
          do{j--;}
          while(j);
          i--;
          }while(i);
}

/*--------------------------延时2400us程子程序-----------------------*/

delay2400()                                          
{
uchar i,j;
i=5;
do{j=237;
          do{j--;}
          while(j);
          i--;
          }while(i);
}
//**************************************************************


//**************************************************************
/*----------------------------------------------------------*/
/*-----------------------红外解码程序(核心)-----------------*/
/*----------------------------------------------------------*/

void IR_decode()
{
          uchar          i,j;

          while(IR_RE==0);
          delay2400();
          if(IR_RE==1)                                       //延时2.4ms后如果是高电平则是新码
          {
              delay1000();

              delay1000();


          for(i=0;i<4;i++)
          {
            for(j=0;j<8;j++)
            {
                   while(IR_RE==0);                               //等待地址码第1位高电平到来
                   delay882();                                 //延时882us判断此时引脚电平
             ///CY=IR_RE;
                   if(IR_RE==0)
                   {       
             date[i]>>=1;
             date[i]=date[i]|0x00;     
                   }
                   else if(IR_RE==1)
             {
             delay1000();
             date[i]>>=1;
             date[i]=date[i]|0x80;
             }
          }                                            //1位数据接收结束
             }                                               //32位二进制码接收结束
           } 
}

//*****************************************************************


//********************************************************************
/*------------------------外部中断0程序-------------------------*/
/*------------------主要用于处理红外遥控键值--------------------*/

void int0() interrupt 0
{ 
           uchar i;
           k=0;

           EX0=0;                                        //检测到有效信号关中断，防止干扰
           for(i=0;i<4;i++)
           { 
             delay1000();
          if(IR_RE==1){k=1;}                           //刚开始为9ms的引导码.
           }

           if(k==0)
           { 
//           EX0=0;                                        //检测到有效信号关中断，防止干扰
           IR_decode();                                  //如果接收到的是有效信号，则调用解码程序
           P0=date[1];
         
           delay2400();
           delay2400();
           delay2400();
          }

            EX0=1;                                         //开外部中断，允许新的遥控按键
}

//*********************************************************************


//********************************
void main()
{
          SP=0x60;                                        //堆栈指针
          EX0=1;                                          //允许外部中断0,用于检测红外遥控器按键
          EA=1;                                           //总中断开
          while(1);
}

总结:关于本段程序的精确延时在<<C51中精确的延时与计算的实现>>里的评论有很好的诠释.

以上程序段可以应用在51/52单片机里.下面的程序可以应用在STC12C5410/STC12C2052型号的单片机里面.

//在STC12C5410上运用红外线解码程序.主要的问题在于延迟上。
#include <regx51.h>

#define uchar unsigned char
#define uint          unsigned int

#define           IR_RE P3_2

bit           k=0;                                              //红外解码判断标志位，为0则为有效信号，为1则为无效

uchar          date[4]={0,0,0,0};                                //date数组为存放地址原码，反码，数据原码，反码

/*--------------------------延时1ms程子程序-----------------------*/
delay1000()
{
uchar i,j;
i=200;
do{j=13;
     do{j--;}
     while(j);
     i--;
     }while(i);
}
//****************************************


/*---------------------------延时882us子程序-----------------------*/

delay882()
{
uchar i,j;
i=84;
do{j=30;
          do{j--;}
          while(j);
          i--;
          }while(i);
}

/*--------------------------延时2400us程子程序-----------------------*/

delay2400()                                          
{
uchar i,j;
i=200;
do{j=34;
          do{j--;}
          while(j);
          i--;
          }while(i);
}
//**************************************************************


//**************************************************************
/*----------------------------------------------------------*/
/*-----------------------红外解码程序(核心)-----------------*/
/*----------------------------------------------------------*/

void IR_decode()
{
          uchar          i,j;

          while(IR_RE==0);
          delay2400();
          if(IR_RE==1)                                       //延时2.4ms后如果是高电平则是新码
          {
              delay1000();

              delay1000();


          for(i=0;i<4;i++)
          {
            for(j=0;j<8;j++)
            {
                   while(IR_RE==0);                               //等待地址码第1位高电平到来
                   delay882();                                 //延时882us判断此时引脚电平
             ///CY=IR_RE;
                   if(IR_RE==0)
                   {       
             date[i]>>=1;
             date[i]=date[i]|0x00;     
                   }
                   else if(IR_RE==1)
             {
             delay1000();
             date[i]>>=1;
             date[i]=date[i]|0x80;
             }
          }                                            //1位数据接收结束
             }                                               //32位二进制码接收结束
           } 
}

//*****************************************************************


//********************************************************************
/*------------------------外部中断0程序-------------------------*/
/*------------------主要用于处理红外遥控键值--------------------*/

void int0() interrupt 0
{ 
           uchar i;
           k=0;

           EX0=0;                                        //检测到有效信号关中断，防止干扰
           for(i=0;i<4;i++)
           { 
             delay1000();
          if(IR_RE==1){k=1;}                           //刚开始为9ms的引导码.
           }

           if(k==0)
           { 
//           EX0=0;                                        //检测到有效信号关中断，防止干扰
           IR_decode();                                  //如果接收到的是有效信号，则调用解码程序
           P1=date[3];

           delay2400();
           delay2400();
           delay2400();
           }

            EX0=1;                                         //开外部中断，允许新的遥控按键
}

//*********************************************************************


//****************
//主函数。             
void main()
{
SP=0x60;
EX0=1;
EA=1;
while(1);
}


通过查询法的遥控解码子程序:

//*************************************
#include <regx51.h>

#define uchar unsigned char
#define uint         unsigned int

#define          IR_RE P3_2

bit          k=0;                                             //红外解码判断标志位，为0则为有效信号，为1则为无效

uchar         date[4]={0,0,0,0};                               //date数组为存放地址原码，反码，数据原码，反码


/*--------------------------延时1ms程子程序-----------------------*/
delay1000()             
{
uchar i,j;
i=5;
do{j=95;
         do{j--;}
         while(j);
         i--;
         }while(i);
}

/*---------------------------延时882us子程序-----------------------*/

delay882()
{
uchar i,j;
i=6;
do{j=71;
         do{j--;}
         while(j);
         i--;
         }while(i);
}

/*--------------------------延时2400us程子程序-----------------------*/

delay2400()                                          
{
uchar i,j;
i=5;
do{j=237;
         do{j--;}
         while(j);
         i--;
         }while(i);
}
//**************************************************************


//**************************************************************
/*----------------------------------------------------------*/
/*-----------------------红外解码程序(核心)-----------------*/
/*----------------------------------------------------------*/

void IR_decode()
{
         uchar         i,j;

         while(IR_RE==0);
         delay2400();
         if(IR_RE==1)                                      //延时2.4ms后如果是高电平则是新码
         {
             delay1000();

             delay1000();


         for(i=0;i<4;i++)
         {
           for(j=0;j<8;j++)
           {
                  while(IR_RE==0);                              //等待地址码第1位高电平到来
                  delay882();                                //延时882us判断此时引脚电平
            ///CY=IR_RE;
                  if(IR_RE==0)
                  {       
            date[i]>>=1;
            date[i]=date[i]|0x00;     
                  }
                  else if(IR_RE==1)
            {
            delay1000();
            date[i]>>=1;
            date[i]=date[i]|0x80;
            }
         }                                           //1位数据接收结束
            }                                              //32位二进制码接收结束
          } 
}

//*****************************************************************


//********************************************************************
/*------------------主要用于处理红外遥控键值--------------------*/

void jiema()
{ 
          uchar i;
          k=0;

          for(i=0;i<8;i++)
          { 
            delay1000();
         if(IR_RE==1)                         //刚开始为9ms的引导码.
          {
    k=1;
    break;
    } 
    }

          if(k==0)
          { 
          IR_decode();                                 //如果接收到的是有效信号，则调用解码程序
          P0=date[3];
          delay2400();
          delay2400();
          delay2400();
          }
}

//*********************************************************************


//********************************
void main()
{
         SP=0x60;                                       //堆栈指针
   while(1)
   {
   while(IR_RE==0)
    jiema();
   }
}

//********************************************
 
